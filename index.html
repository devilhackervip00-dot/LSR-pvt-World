<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>THE BDT PREDICTOR V.4 (Loss Reduction)</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Outfit', sans-serif; background: #000; color: #fff; margin: 0; padding: 10px; text-align: center; }
    .header { font-size: 20px; font-weight: bold; color: #00ffea; margin-bottom: 10px; }
    .card { background: #111; border: 1px solid #00ffea; border-radius: 10px; padding: 10px; margin-bottom: 12px; }
    .prediction-btn { margin: 10px auto; display: block; background: #00ffea33; color: #00ffea; border: 1px solid #00ffea;
      border-radius: 8px; padding: 12px; font-weight: bold; font-size: 18px; }
    #patternBox { color: #aaa; font-size: 14px; margin-top: 5px; }
    .tab-buttons { display: flex; border: 1px solid #00ffea; border-radius: 8px; overflow: hidden; margin-bottom: 10px; }
    .tab-buttons button { flex: 1; background: #111; color: #00ffea; padding: 8px; border: none; cursor: pointer; font-weight: bold; }
    .tab-buttons button.active { background: #00ffea33; }
    .history-container { border: 1px solid #00ffea; border-radius: 8px; overflow: hidden; max-height: 400px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; }
    th, td { font-size: 13px; border-bottom: 1px solid #222; padding: 6px; }
    th { background: #111; color: #00ffea; position: sticky; top: 0; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .dot.red { background: red; } .dot.green { background: lime; } .dot.violet { background: violet; }
    .num.red { color: red; font-weight: bold; } .num.green { color: lime; font-weight: bold; } .num.violet { color: violet; font-weight: bold; }
    .status.win { color: lime; font-weight: bold; } .status.loss { color: red; font-weight: bold; }
    .analysis-container { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 15px; }
    .analysis-card { background: #111; border: 1px solid #00ffea; border-radius: 8px; padding: 10px; text-align: left; }
    .analysis-card h3 { color: #00ffea; margin-top: 0; font-size: 14px; }
    .analysis-data { font-size: 12px; line-height: 1.6; }
    .hot { color: #ff6b6b; } .cold { color: #4fc3f7; }
    .loader { border: 2px solid #333; border-top: 2px solid #00ffea; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; margin: 10px auto; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .win-rate { margin-top: 10px; font-size: 14px; }
    .strategy { background: #1a1a1a; padding: 10px; border-radius: 8px; margin-top: 10px; text-align: left; }
    .strategy h4 { color: #00ffea; margin-top: 0; }
    .heat-bar { height: 5px; background: #333; margin-top: 3px; border-radius: 3px; }
    .heat-fill { height: 100%; border-radius: 3px; }
  </style>
</head>
<body>
  <div class="header">𝐓𝐇𝐄 𝐋𝐒𝐑 𝐏𝐑𝐄𝐃𝐈𝐂𝐓𝐎𝐑 𝐕.6</div>
  <div class="card">
    <div id="currentPeriod">Current Period: Loading...</div>
    <div id="liveTime">Time: --:--:--</div>
    <div id="predictionBox" class="prediction-btn">Prediction → Analyzing...</div>
    <div id="confidenceBox">Confidence: --%</div>
    <div id="patternBox">Pattern: --</div>
    <div id="winRate" class="win-rate">Win Rate: --%</div>
  </div>

  <div class="tab-buttons">
    <button id="predTab" class="active">Prediction History</button>
    <button id="gameTab">Game History</button>
    <button id="analysisTab">Number Analysis</button>
    <button id="strategyTab">Strategy</button>
  </div>

  <div class="history-container">
    <table>
      <thead id="tableHead"></thead>
      <tbody id="tableBody"><tr><td>Loading...</td></tr></tbody>
    </table>
  </div>

  <div id="analysisContainer" class="analysis-container" style="display: none;">
    <div class="analysis-card">
      <h3>Hot Numbers (Frequent)</h3>
      <div id="hotNumbers" class="analysis-data">Loading...</div>
    </div>
    <div class="analysis-card">
      <h3>Cold Numbers (Missing)</h3>
      <div id="coldNumbers" class="analysis-data">Loading...</div>
    </div>
    <div class="analysis-card">
      <h3>Frequency Analysis</h3>
      <div id="frequencyAnalysis" class="analysis-data">Loading...</div>
    </div>
    <div class="analysis-card">
      <h3>Consecutive Analysis</h3>
      <div id="consecutiveAnalysis" class="analysis-data">Loading...</div>
    </div>
  </div>

  <div id="strategyContainer" style="display: none;">
    <div class="strategy">
      <h4>Loss Reduction Strategy</h4>
      <p>1. <strong>Pattern Break Detection:</strong> Identifies when streaks are statistically likely to end</p>
      <p>2. <strong>Imbalance Correction:</strong> Bets against significant imbalances (difference > 15)</p>
      <p>3. <strong>Heat-based Prediction:</strong> Uses hot/cold number analysis for better predictions</p>
      <p>4. <strong>Adaptive Confidence:</strong> Adjusts confidence based on pattern strength</p>
      <p>5. <strong>Trend Following:</strong> Identifies and follows short-term trends</p>
    </div>
    <div class="strategy">
      <h4>Current Strategy</h4>
      <div id="currentStrategy">Analyzing patterns...</div>
    </div>
  </div>

<script>
const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

const REQUEST_DATA = {
  typeId: 1,
  language: 0,
  random: "e7fe6c090da2495ab8290dac551ef1ed",
  signature: "1F390E2B2D8A55D693E57FD905AE73A7",
  timestamp: 1723726679
};

let predictionHistory = [];
let last100Results = [];
let winCount = 0;
let lossCount = 0;

// Utility to determine Big/Small based on number
function getBigSmall(num) {
  return num >= 5 ? "Big" : "Small";
}

// Utility to determine color (used only for game history display)
function getColor(num) {
  if ([1, 3, 7, 9].includes(num)) return "Green";
  if ([2, 4, 6, 8].includes(num)) return "Red";
  return "Violet";
}

// Update live time display
function updateLiveTime() {
  document.getElementById("liveTime").innerText = "Time: " + new Date().toLocaleTimeString('en-GB');
}

/**
 * AI Prediction Logic: Analyzes statistical patterns for Big/Small predictions
 * with a focus on loss reduction
 * @param {Array} history - Array of historical game data
 * @returns {Object} - Prediction text, confidence, and pattern name
 */
function predict(history) {
  if (history.length < 10) {
    return { text: "Analyzing...", conf: "--", pattern: "Awaiting data" };
  }

  // Get the last 100 results for analysis
  const last100 = last100Results.length > 0 ? last100Results : history.slice(0, 100);
  
  // Count occurrences of Big and Small
  let bigCount = 0;
  let smallCount = 0;
  
  last100.forEach(item => {
    if (item.size === "Big") bigCount++;
    else smallCount++;
  });
  
  // Calculate probabilities
  const bigProbability = bigCount / last100.length;
  const smallProbability = smallCount / last100.length;
  
  // Check for streaks
  const last5 = history.slice(0, 5).map(h => h.size);
  const currentStreak = getCurrentStreak(last5);
  
  // Check for imbalance
  const imbalance = Math.abs(bigCount - smallCount);
  const imbalanceThreshold = 15; // If difference is more than 15
  
  // Advanced prediction logic with loss reduction
  if (imbalance > imbalanceThreshold) {
    // If there's a significant imbalance, predict the less frequent
    const prediction = bigCount > smallCount ? "Small" : "Big";
    const confidence = Math.min(95, 75 + Math.floor(imbalance / 2));
    return { 
      text: prediction, 
      conf: confidence, 
      pattern: `Imbalance correction (${imbalance} difference)` 
    };
  } else if (currentStreak.count >= 3) {
    // If there's a streak of 3 or more, predict break (but with caution)
    const prediction = currentStreak.type === "Big" ? "Small" : "Big";
    
    // Higher confidence for longer streaks but cap at 4+ streaks
    let confidence = 80;
    if (currentStreak.count === 3) confidence = 82;
    if (currentStreak.count === 4) confidence = 85;
    if (currentStreak.count >= 5) confidence = 88;
    
    return { 
      text: prediction, 
      conf: confidence, 
      pattern: `Streak break (${currentStreak.count} ${currentStreak.type})` 
    };
  } else {
    // Use heat-based prediction (analyze hot numbers)
    const heatPrediction = heatBasedPrediction(history);
    if (heatPrediction.conf > 80) {
      return heatPrediction;
    }
    
    // Otherwise, predict based on probability with slight adjustment for recent trends
    const recentTrend = getRecentTrend(history.slice(0, 10));
    let prediction;
    let confidence;
    
    if (Math.abs(bigProbability - smallProbability) < 0.1) {
      // If probabilities are close, follow recent trend
      prediction = recentTrend;
      confidence = 75;
      pattern = "Recent trend";
    } else {
      // Otherwise, follow the higher probability but with caution
      prediction = bigProbability > smallProbability ? "Big" : "Small";
      confidence = Math.floor(Math.max(bigProbability, smallProbability) * 80);
      pattern = "Probability based";
    }
    
    return { text: prediction, conf: confidence, pattern };
  }
}

// Heat-based prediction using number analysis
function heatBasedPrediction(history) {
  const stats = analyzeNumbers(last100Results);
  const recentNumbers = history.slice(0, 5).map(h => h.number);
  
  // Check if recent numbers are mostly hot or cold
  let hotCount = 0;
  let coldCount = 0;
  
  recentNumbers.forEach(num => {
    if (stats[num].missing <= 5) hotCount++;
    else if (stats[num].missing >= 15) coldCount++;
  });
  
  // If mostly hot numbers, predict continuation of hot numbers (which are more likely to be Big)
  if (hotCount >= 3) {
    const hotBigCount = recentNumbers.filter(n => n >= 5 && stats[n].missing <= 5).length;
    const hotSmallCount = hotCount - hotBigCount;
    
    if (hotBigCount > hotSmallCount) {
      return { text: "Big", conf: 82, pattern: "Hot numbers trend (Big)" };
    } else if (hotSmallCount > hotBigCount) {
      return { text: "Small", conf: 82, pattern: "Hot numbers trend (Small)" };
    }
  }
  
  // If mostly cold numbers, predict change
  if (coldCount >= 3) {
    const coldBigCount = recentNumbers.filter(n => n >= 5 && stats[n].missing >= 15).length;
    const coldSmallCount = coldCount - coldBigCount;
    
    if (coldBigCount > coldSmallCount) {
      return { text: "Small", conf: 78, pattern: "Cold numbers reversal (to Small)" };
    } else if (coldSmallCount > coldBigCount) {
      return { text: "Big", conf: 78, pattern: "Cold numbers reversal (to Big)" };
    }
  }
  
  return { text: "", conf: 0, pattern: "" };
}

// Get current streak information
function getCurrentStreak(lastResults) {
  if (lastResults.length < 1) return { type: null, count: 0 };
  
  let type = lastResults[0];
  let count = 1;
  
  for (let i = 1; i < lastResults.length; i++) {
    if (lastResults[i] === type) {
      count++;
    } else {
      break;
    }
  }
  
  return { type, count };
}

// Get recent trend (last 10 results)
function getRecentTrend(history) {
  if (history.length < 5) return "Big"; // Default
  
  let bigCount = 0;
  let smallCount = 0;
  
  history.slice(0, 10).forEach(item => {
    if (item.size === "Big") bigCount++;
    else smallCount++;
  });
  
  return bigCount > smallCount ? "Big" : "Small";
}

/**
 * Analyze last 100 periods for number statistics
 */
function analyzeNumbers(history) {
  const numbers = Array(10).fill().map((_, i) => i); // 0-9
  const stats = {};
  
  // Initialize stats
  numbers.forEach(num => {
    stats[num] = {
      frequency: 0,
      lastSeen: null,
      missing: 0,
      maxConsecutive: 0,
      currentConsecutive: 0
    };
  });
  
  // Process history to calculate stats
  for (let i = history.length - 1; i >= 0; i--) {
    const num = history[i].number;
    stats[num].frequency++;
    
    // Update missing counts
    numbers.forEach(n => {
      if (n !== num) {
        stats[n].missing++;
      } else {
        stats[n].missing = 0;
      }
    });
    
    // Update consecutive
    if (i < history.length - 1) {
      if (num === history[i + 1].number) {
        stats[num].currentConsecutive++;
        stats[num].maxConsecutive = Math.max(stats[num].maxConsecutive, stats[num].currentConsecutive);
      } else {
        stats[num].currentConsecutive = 1;
      }
    }
  }
  
  return stats;
}

/**
 * Update analysis displays
 */
function updateAnalysisDisplays(stats) {
  // Hot numbers (most frequent)
  const hotNumbers = Object.entries(stats)
    .sort((a, b) => b[1].frequency - a[1].frequency)
    .slice(0, 5)
    .map(([num, data]) => `${num} (${data.frequency})`);
  
  document.getElementById("hotNumbers").innerHTML = hotNumbers.join(", ");
  
  // Cold numbers (missing longest)
  const coldNumbers = Object.entries(stats)
    .sort((a, b) => b[1].missing - a[1].missing)
    .slice(0, 5)
    .map(([num, data]) => `${num} (${data.missing})`);
  
  document.getElementById("coldNumbers").innerHTML = coldNumbers.join(", ");
  
  // Frequency analysis
  let frequencyHtml = "";
  Object.entries(stats).forEach(([num, data]) => {
    const heat = Math.min(100, Math.max(0, 100 - (data.missing * 5)));
    frequencyHtml += `
      <div>${num}: ${data.frequency} times 
        <div class="heat-bar">
          <div class="heat-fill" style="width: ${heat}%; background: ${heat > 70 ? '#ff6b6b' : heat > 40 ? '#ffa500' : '#4fc3f7'};"></div>
        </div>
      </div>`;
  });
  document.getElementById("frequencyAnalysis").innerHTML = frequencyHtml;
  
  // Consecutive analysis
  let consecutiveHtml = "";
  Object.entries(stats).forEach(([num, data]) => {
    consecutiveHtml += `<div>${num}: Max ${data.maxConsecutive} consecutive</div>`;
  });
  document.getElementById("consecutiveAnalysis").innerHTML = consecutiveHtml;
}

// Update win rate display
function updateWinRate() {
  const total = winCount + lossCount;
  const winRate = total > 0 ? Math.round((winCount / total) * 100) : 0;
  document.getElementById("winRate").innerText = `Win Rate: ${winRate}% (${winCount}W/${lossCount}L)`;
}

/**
 * Fetch game data and update UI
 */
async function fetchData() {
  try {
    // Fetch current period
    const periodRes = await fetch(CURRENT_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...REQUEST_DATA, timestamp: Math.floor(Date.now() / 1000) })
    });
    if (!periodRes.ok) throw new Error(`Period API failed: ${periodRes.status}`);
    const periodData = await periodRes.json();
    const period = periodData?.data?.issueNumber || "Unavailable";
    document.getElementById("currentPeriod").innerText = `Current Period: ${period}`;

    // Fetch history
    const res = await fetch(HISTORY_API + '?ts=' + Date.now());
    if (!res.ok) throw new Error(`History API failed: ${res.status}`);
    const data = await res.json();
    if (!data?.data?.list) throw new Error("Invalid history data");

    // Process last 100 results for analysis
    last100Results = data.data.list.slice(0, 100).map(item => {
      const num = parseInt(item.number);
      return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num) };
    });

    // Process recent history for prediction
    const recentHistory = data.data.list.slice(0, 20).map(item => {
      const num = parseInt(item.number);
      return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num) };
    });

    // Generate prediction
    const prediction = predict(recentHistory);
    document.getElementById("predictionBox").innerText = `Prediction → ${prediction.text}`;
    document.getElementById("confidenceBox").innerText = `Confidence: ${prediction.conf}%`;
    document.getElementById("patternBox").innerText = `Pattern: ${prediction.pattern}`;

    // Update prediction history
    if (prediction.text !== "Analyzing..." && period !== "Unavailable") {
      if (!predictionHistory.find(p => p.period === period)) {
        predictionHistory.unshift({ period, prediction: prediction.text, actual: "--", status: "Waiting" });
        if (predictionHistory.length > 20) predictionHistory.pop();
      }
    }

    // Update prediction results
    predictionHistory.forEach(ph => {
      const match = recentHistory.find(h => h.period === ph.period);
      if (match && ph.status === "Waiting") {
        ph.actual = match.size;
        ph.status = ph.prediction === ph.actual ? "Win" : "Loss";
        
        // Update win/loss counts
        if (ph.status === "Win") winCount++;
        else lossCount++;
      }
    });

    // Update number analysis
    const stats = analyzeNumbers(last100Results);
    updateAnalysisDisplays(stats);
    
    // Update win rate
    updateWinRate();

    renderTable();
  } catch (e) {
    document.getElementById("predictionBox").innerText = "Prediction Error";
    document.getElementById("currentPeriod").innerText = "Current Period: Error";
    console.error("Fetch error:", e.message);
  }
}

/**
 * Render prediction or game history table
 */
function renderTable() {
  const head = document.getElementById("tableHead");
  const body = document.getElementById("tableBody");

  if (document.getElementById("predTab").classList.contains("active")) {
    head.innerHTML = "<tr><th>Period</th><th>Prediction</th><th>Actual</th><th>Status</th></tr>";
    body.innerHTML = predictionHistory.length === 0
      ? "<tr><td colspan='4'>No predictions yet</td></tr>"
      : predictionHistory.map(item => `
        <tr>
          <td>${item.period}</td>
          <td>${item.prediction}</td>
          <td>${item.actual}</td>
          <td class="status ${item.status.toLowerCase()}">${item.status}</td>
        </tr>`).join("");
  } else if (document.getElementById("gameTab").classList.contains("active")) {
    head.innerHTML = "<tr><th>Period</th><th>Number</th><th>Big/Small</th><th>Color</th></tr>";
    body.innerHTML = "";
    fetch(HISTORY_API + '?ts=' + Date.now())
      .then(res => {
        if (!res.ok) throw new Error(`History API failed: ${res.status}`);
        return res.json();
      })
      .then(data => {
        if (!data?.data?.list) throw new Error("Invalid history data");
        const history = data.data.list.slice(0, 10).map(item => {
          const num = parseInt(item.number);
          return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num) };
        });
        body.innerHTML = history.map(item => {
          const colorClass = item.color.toLowerCase();
          return `
            <tr>
              <td>${item.period}</td>
              <td class="num ${colorClass}">${item.number}</td>
              <td>${item.size}</td>
              <td><span class="dot ${colorClass}"></span></td>
            </tr>`;
        }).join("");
      })
      .catch(e => {
        body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
        console.error("Game history error:", e.message);
      });
  }
}

// Event listeners for tabs
document.getElementById("predTab").onclick = () => {
  document.getElementById("predTab").classList.add("active");
  document.getElementById("gameTab").classList.remove("active");
  document.getElementById("analysisTab").classList.remove("active");
  document.getElementById("strategyTab").classList.remove("active");
  document.getElementById("analysisContainer").style.display = "none";
  document.getElementById("strategyContainer").style.display = "none";
  renderTable();
};

document.getElementById("gameTab").onclick = () => {
  document.getElementById("gameTab").classList.add("active");
  document.getElementById("predTab").classList.remove("active");
  document.getElementById("analysisTab").classList.remove("active");
  document.getElementById("strategyTab").classList.remove("active");
  document.getElementById("analysisContainer").style.display = "none";
  document.getElementById("strategyContainer").style.display = "none";
  renderTable();
};

document.getElementById("analysisTab").onclick = () => {
  document.getElementById("analysisTab").classList.add("active");
  document.getElementById("predTab").classList.remove("active");
  document.getElementById("gameTab").classList.remove("active");
  document.getElementById("strategyTab").classList.remove("active");
  document.getElementById("analysisContainer").style.display = "grid";
  document.getElementById("strategyContainer").style.display = "none";
  document.getElementById("tableHead").innerHTML = "";
  document.getElementById("tableBody").innerHTML = "<tr><td>Number analysis displayed above</td></tr>";
};

document.getElementById("strategyTab").onclick = () => {
  document.getElementById("strategyTab").classList.add("active");
  document.getElementById("predTab").classList.remove("active");
  document.getElementById("gameTab").classList.remove("active");
  document.getElementById("analysisTab").classList.remove("active");
  document.getElementById("analysisContainer").style.display = "none";
  document.getElementById("strategyContainer").style.display = "block";
  document.getElementById("tableHead").innerHTML = "";
  document.getElementById("tableBody").innerHTML = "<tr><td>Strategy information displayed above</td></tr>";
};

// Initialize
setInterval(updateLiveTime, 1000);
setInterval(fetchData, 10000);
fetchData();
updateLiveTime();
</script>
</body>
</html>